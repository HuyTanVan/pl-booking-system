// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: ticket.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createTicket = `-- name: CreateTicket :one
INSERT INTO tickets (
    match_id,
    seat_id,
    price,
    is_available,
    created_at,
    updated_at
)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, match_id, seat_id, price, is_available, created_at, updated_at
`

type CreateTicketParams struct {
	MatchID     int32     `json:"match_id"`
	SeatID      int32     `json:"seat_id"`
	Price       string    `json:"price"`
	IsAvailable bool      `json:"is_available"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

func (q *Queries) CreateTicket(ctx context.Context, arg CreateTicketParams) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, createTicket,
		arg.MatchID,
		arg.SeatID,
		arg.Price,
		arg.IsAvailable,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.MatchID,
		&i.SeatID,
		&i.Price,
		&i.IsAvailable,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTicketByID = `-- name: GetTicketByID :one
SELECT id, match_id, seat_id, price, is_available, created_at, updated_at FROM tickets
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTicketByID(ctx context.Context, id int32) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, getTicketByID, id)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.MatchID,
		&i.SeatID,
		&i.Price,
		&i.IsAvailable,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTicketWithDetails = `-- name: GetTicketWithDetails :one
SELECT
	t.id,
	t.match_id,
	t.seat_id,
	t.price,
	t.is_available AS ticket_avalable,
	home_team.name AS home_team,
	away_team.name AS away_team,
	m.match_date AS match_date,
	sta.location AS stadium_location,
	s.block,
	s.row,
	s.seat_column
FROM tickets t 
LEFT JOIN matches AS m ON t.match_id = m.id
LEFT JOIN teams AS home_team ON m.home_team_id = home_team.id
LEFT JOIN teams AS away_team ON m.away_team_id = away_team.id
LEFT JOIN seats AS s ON t.seat_id = s.id
LEFT JOIN stadiums AS sta ON s.stadium_id = sta.id
WHERE t.id = $1
LIMIT 1
`

type GetTicketWithDetailsRow struct {
	ID              int32          `json:"id"`
	MatchID         int32          `json:"match_id"`
	SeatID          int32          `json:"seat_id"`
	Price           string         `json:"price"`
	TicketAvalable  bool           `json:"ticket_avalable"`
	HomeTeam        sql.NullString `json:"home_team"`
	AwayTeam        sql.NullString `json:"away_team"`
	MatchDate       sql.NullTime   `json:"match_date"`
	StadiumLocation sql.NullString `json:"stadium_location"`
	Block           sql.NullString `json:"block"`
	Row             sql.NullString `json:"row"`
	SeatColumn      sql.NullString `json:"seat_column"`
}

func (q *Queries) GetTicketWithDetails(ctx context.Context, id int32) (GetTicketWithDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getTicketWithDetails, id)
	var i GetTicketWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.MatchID,
		&i.SeatID,
		&i.Price,
		&i.TicketAvalable,
		&i.HomeTeam,
		&i.AwayTeam,
		&i.MatchDate,
		&i.StadiumLocation,
		&i.Block,
		&i.Row,
		&i.SeatColumn,
	)
	return i, err
}

const listMinPriceOfTicketsByMatch = `-- name: ListMinPriceOfTicketsByMatch :many
SELECT
	t.match_id AS match_id, 
	min(t.price) AS min_price
FROM tickets t
LEFT JOIN matches m on m.id = t.match_id
group by t.match_id
ORDER BY min_price
`

type ListMinPriceOfTicketsByMatchRow struct {
	MatchID  int32       `json:"match_id"`
	MinPrice interface{} `json:"min_price"`
}

func (q *Queries) ListMinPriceOfTicketsByMatch(ctx context.Context) ([]ListMinPriceOfTicketsByMatchRow, error) {
	rows, err := q.db.QueryContext(ctx, listMinPriceOfTicketsByMatch)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMinPriceOfTicketsByMatchRow{}
	for rows.Next() {
		var i ListMinPriceOfTicketsByMatchRow
		if err := rows.Scan(&i.MatchID, &i.MinPrice); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTickets = `-- name: ListTickets :many
SELECT id, match_id, seat_id, price, is_available, created_at, updated_at FROM tickets
WHERE match_id = $1
ORDER BY price
LIMIT $2
OFFSET $3
`

type ListTicketsParams struct {
	MatchID int32 `json:"match_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) ListTickets(ctx context.Context, arg ListTicketsParams) ([]Ticket, error) {
	rows, err := q.db.QueryContext(ctx, listTickets, arg.MatchID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Ticket{}
	for rows.Next() {
		var i Ticket
		if err := rows.Scan(
			&i.ID,
			&i.MatchID,
			&i.SeatID,
			&i.Price,
			&i.IsAvailable,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTicketsWithDetails = `-- name: ListTicketsWithDetails :many
SELECT
	t.id,
	t.match_id,
	t.seat_id,
	t.price,
	t.is_available AS ticket_avalable,
	home_team.name AS home_team,
	away_team.name AS away_team,
	m.match_date AS match_date,
	sta.location AS stadium_location,
	s.block,
	s.row,
	s.seat_column
FROM tickets t 
LEFT JOIN matches AS m ON t.match_id = m.id
LEFT JOIN teams AS home_team ON m.home_team_id = home_team.id
LEFT JOIN teams AS away_team ON m.away_team_id = away_team.id
LEFT JOIN seats AS s ON t.seat_id = s.id
LEFT JOIN stadiums AS sta ON s.stadium_id = sta.id
WHERE t.match_id = $1
ORDER BY t.price
LIMIT $2
OFFSET $3
`

type ListTicketsWithDetailsParams struct {
	MatchID int32 `json:"match_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

type ListTicketsWithDetailsRow struct {
	ID              int32          `json:"id"`
	MatchID         int32          `json:"match_id"`
	SeatID          int32          `json:"seat_id"`
	Price           string         `json:"price"`
	TicketAvalable  bool           `json:"ticket_avalable"`
	HomeTeam        sql.NullString `json:"home_team"`
	AwayTeam        sql.NullString `json:"away_team"`
	MatchDate       sql.NullTime   `json:"match_date"`
	StadiumLocation sql.NullString `json:"stadium_location"`
	Block           sql.NullString `json:"block"`
	Row             sql.NullString `json:"row"`
	SeatColumn      sql.NullString `json:"seat_column"`
}

// select t.*,
//
//	s.stadium_id,
//	s.block,
//	s.row,
//	s.is_available
//
// from
// tickets AS t
// left JOIN seats AS s ON t.seat_id = s.id;
func (q *Queries) ListTicketsWithDetails(ctx context.Context, arg ListTicketsWithDetailsParams) ([]ListTicketsWithDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, listTicketsWithDetails, arg.MatchID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTicketsWithDetailsRow{}
	for rows.Next() {
		var i ListTicketsWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.MatchID,
			&i.SeatID,
			&i.Price,
			&i.TicketAvalable,
			&i.HomeTeam,
			&i.AwayTeam,
			&i.MatchDate,
			&i.StadiumLocation,
			&i.Block,
			&i.Row,
			&i.SeatColumn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTicket = `-- name: UpdateTicket :exec
UPDATE tickets
SET match_id = coalesce($2, match_id),
    seat_id = coalesce($3, seat_id),
    price = coalesce($4, price),
    is_available = coalesce($5, is_available)
WHERE id=$1
`

type UpdateTicketParams struct {
	ID          int32          `json:"id"`
	MatchID     sql.NullInt32  `json:"match_id"`
	SeatID      sql.NullInt32  `json:"seat_id"`
	Price       sql.NullString `json:"price"`
	IsAvailable sql.NullBool   `json:"is_available"`
}

func (q *Queries) UpdateTicket(ctx context.Context, arg UpdateTicketParams) error {
	_, err := q.db.ExecContext(ctx, updateTicket,
		arg.ID,
		arg.MatchID,
		arg.SeatID,
		arg.Price,
		arg.IsAvailable,
	)
	return err
}
