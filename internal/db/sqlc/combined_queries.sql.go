// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: combined_queries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const fetchHomePageDetails = `-- name: FetchHomePageDetails :many
SELECT
  m.id, m.home_team_id, m.away_team_id, m.stadium_id, m.match_date, m.session, m.status,
  home_team.name AS home_team_name,
  away_team.name AS away_team_name,
  stadium.name AS stadium_name,
  COUNT(CASE WHEN ticket.is_available = true THEN 1 END) AS available,
  TO_CHAR(MIN(CASE WHEN ticket.price > 0 THEN ticket.price ELSE 0 END)::float, 'FM999999999.00') AS min_price
FROM matches m
LEFT JOIN teams AS home_team ON m.home_team_id = home_team.id
LEFT JOIN teams AS away_team ON m.away_team_id = away_team.id
LEFT JOIN stadiums AS stadium ON m.stadium_id = stadium.id
LEFT JOIN tickets AS ticket ON m.id = ticket.match_id
WHERE m.match_date >= CURRENT_DATE
  AND m.match_date <= 
      CASE
        WHEN $3 = 'a' THEN CURRENT_DATE + INTERVAL '90 DAY'
        WHEN $3 = 't' THEN CURRENT_DATE + INTERVAL '1 DAY'
        WHEN $3 = 'w' THEN CURRENT_DATE + INTERVAL '7 DAY'
        WHEN $3 = 'm' THEN CURRENT_DATE + INTERVAL '30 DAY'
        ELSE COALESCE($4, CURRENT_DATE)  -- Default to today if no custom date
      END
GROUP BY m.id, home_team.name, away_team.name, stadium.name
ORDER BY 
      CASE
        WHEN $5 = 'd' THEN match_date
        -- WHEN sqlc.narg('sortby') = 'p' THEN min_price
        ELSE COALESCE($4, m.match_date)
      END
LIMIT $1
OFFSET $2
`

type FetchHomePageDetailsParams struct {
	Limit     int32        `json:"limit"`
	Offset    int32        `json:"offset"`
	Range     interface{}  `json:"range"`
	MatchDate sql.NullTime `json:"match_date"`
	Sortby    interface{}  `json:"sortby"`
}

type FetchHomePageDetailsRow struct {
	ID           int32          `json:"id"`
	HomeTeamID   int32          `json:"home_team_id"`
	AwayTeamID   int32          `json:"away_team_id"`
	StadiumID    int32          `json:"stadium_id"`
	MatchDate    time.Time      `json:"match_date"`
	Session      string         `json:"session"`
	Status       string         `json:"status"`
	HomeTeamName sql.NullString `json:"home_team_name"`
	AwayTeamName sql.NullString `json:"away_team_name"`
	StadiumName  sql.NullString `json:"stadium_name"`
	Available    int64          `json:"available"`
	MinPrice     string         `json:"min_price"`
}

// a query getting data needed for homepage
func (q *Queries) FetchHomePageDetails(ctx context.Context, arg FetchHomePageDetailsParams) ([]FetchHomePageDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchHomePageDetails,
		arg.Limit,
		arg.Offset,
		arg.Range,
		arg.MatchDate,
		arg.Sortby,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchHomePageDetailsRow{}
	for rows.Next() {
		var i FetchHomePageDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.StadiumID,
			&i.MatchDate,
			&i.Session,
			&i.Status,
			&i.HomeTeamName,
			&i.AwayTeamName,
			&i.StadiumName,
			&i.Available,
			&i.MinPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTicketsOfMatch = `-- name: ListTicketsOfMatch :many
SELECT
	t.id,
	t.match_id,
	t.seat_id,
	t.price,
	t.is_available AS ticket_avalable,
	home_team.name AS home_team,
	away_team.name AS away_team,
	m.match_date AS match_date,
	sta.location AS stadium_location,
	s.block,
	s.row,
	s.seat_column
FROM tickets t 
LEFT JOIN matches AS m ON t.match_id = m.id
LEFT JOIN teams AS home_team ON m.home_team_id = home_team.id
LEFT JOIN teams AS away_team ON m.away_team_id = away_team.id
LEFT JOIN seats AS s ON t.seat_id = s.id
LEFT JOIN stadiums AS sta ON s.stadium_id = sta.id
WHERE t.match_id = $1
ORDER BY t.price
LIMIT $2
OFFSET $3
`

type ListTicketsOfMatchParams struct {
	MatchID int32 `json:"match_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

type ListTicketsOfMatchRow struct {
	ID              int32          `json:"id"`
	MatchID         int32          `json:"match_id"`
	SeatID          int32          `json:"seat_id"`
	Price           string         `json:"price"`
	TicketAvalable  bool           `json:"ticket_avalable"`
	HomeTeam        sql.NullString `json:"home_team"`
	AwayTeam        sql.NullString `json:"away_team"`
	MatchDate       sql.NullTime   `json:"match_date"`
	StadiumLocation sql.NullString `json:"stadium_location"`
	Block           sql.NullString `json:"block"`
	Row             sql.NullString `json:"row"`
	SeatColumn      sql.NullString `json:"seat_column"`
}

// a query getting all tickets belong to a match
func (q *Queries) ListTicketsOfMatch(ctx context.Context, arg ListTicketsOfMatchParams) ([]ListTicketsOfMatchRow, error) {
	rows, err := q.db.QueryContext(ctx, listTicketsOfMatch, arg.MatchID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTicketsOfMatchRow{}
	for rows.Next() {
		var i ListTicketsOfMatchRow
		if err := rows.Scan(
			&i.ID,
			&i.MatchID,
			&i.SeatID,
			&i.Price,
			&i.TicketAvalable,
			&i.HomeTeam,
			&i.AwayTeam,
			&i.MatchDate,
			&i.StadiumLocation,
			&i.Block,
			&i.Row,
			&i.SeatColumn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
