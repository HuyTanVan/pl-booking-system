// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: match.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createMatch = `-- name: CreateMatch :one
INSERT INTO matches (
    home_team_id,
    away_team_id,
    stadium_id,
    match_date,
    session,
    status
)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, home_team_id, away_team_id, stadium_id, match_date, session, status
`

type CreateMatchParams struct {
	HomeTeamID int32     `json:"home_team_id"`
	AwayTeamID int32     `json:"away_team_id"`
	StadiumID  int32     `json:"stadium_id"`
	MatchDate  time.Time `json:"match_date"`
	Session    string    `json:"session"`
	Status     string    `json:"status"`
}

func (q *Queries) CreateMatch(ctx context.Context, arg CreateMatchParams) (Match, error) {
	row := q.db.QueryRowContext(ctx, createMatch,
		arg.HomeTeamID,
		arg.AwayTeamID,
		arg.StadiumID,
		arg.MatchDate,
		arg.Session,
		arg.Status,
	)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.StadiumID,
		&i.MatchDate,
		&i.Session,
		&i.Status,
	)
	return i, err
}

const getMatchByID = `-- name: GetMatchByID :one

SELECT id, home_team_id, away_team_id, stadium_id, match_date, session, status FROM matches
WHERE id=$1 LIMIT 1
`

// -- name: ListMatchesWithDetails :many
// SELECT
//
//	m.*,
//	home_team.name AS home_team_name,
//	away_team.name AS away_team_name,
//	stadium.name AS stadium_name
//
// FROM matches m
// LEFT JOIN teams AS home_team ON m.home_team_id = home_team.id
// LEFT JOIN teams AS away_team ON m.away_team_id = away_team.id
// LEFT JOIN stadiums AS stadium ON m.stadium_id = stadium.id
// ORDER BY m.match_date
// LIMIT $1
// OFFSET $2;
func (q *Queries) GetMatchByID(ctx context.Context, id int32) (Match, error) {
	row := q.db.QueryRowContext(ctx, getMatchByID, id)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.StadiumID,
		&i.MatchDate,
		&i.Session,
		&i.Status,
	)
	return i, err
}

const listMatches = `-- name: ListMatches :many
SELECT id, home_team_id, away_team_id, stadium_id, match_date, session, status FROM matches
ORDER BY match_date
LIMIT $1
OFFSET $2
`

type ListMatchesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListMatches(ctx context.Context, arg ListMatchesParams) ([]Match, error) {
	rows, err := q.db.QueryContext(ctx, listMatches, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Match{}
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.ID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.StadiumID,
			&i.MatchDate,
			&i.Session,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMatchesWithDetails = `-- name: ListMatchesWithDetails :many
SELECT
  m.id, m.home_team_id, m.away_team_id, m.stadium_id, m.match_date, m.session, m.status,
  home_team.name AS home_team_name,
  away_team.name AS away_team_name,
  stadium.name AS stadium_name,
  COUNT(CASE WHEN ticket.is_available = true THEN 1 END) AS available,
  TO_CHAR(MIN(CASE WHEN ticket.price > 0 THEN ticket.price ELSE 0 END)::float, 'FM999999999.00') AS min_price
FROM matches m
LEFT JOIN teams AS home_team ON m.home_team_id = home_team.id
LEFT JOIN teams AS away_team ON m.away_team_id = away_team.id
LEFT JOIN stadiums AS stadium ON m.stadium_id = stadium.id
LEFT JOIN tickets AS ticket ON m.id = ticket.match_id
WHERE m.match_date >= CURRENT_DATE
  AND m.match_date <= 
      CASE
        WHEN $3 = 'a' THEN CURRENT_DATE + INTERVAL '90 DAY'
        WHEN $3 = 't' THEN CURRENT_DATE + INTERVAL '1 DAY'
        WHEN $3 = 'w' THEN CURRENT_DATE + INTERVAL '7 DAY'
        WHEN $3 = 'm' THEN CURRENT_DATE + INTERVAL '30 DAY'
        ELSE COALESCE($4, CURRENT_DATE)  -- Default to today if no custom date
      END
GROUP BY m.id, home_team.name, away_team.name, stadium.name
ORDER BY 
      CASE
        WHEN $5 = 'd' THEN match_date
        -- WHEN sqlc.narg('sortby') = 'p' THEN min_price
        ELSE COALESCE($4, m.match_date)
      END
LIMIT $1
OFFSET $2
`

type ListMatchesWithDetailsParams struct {
	Limit     int32        `json:"limit"`
	Offset    int32        `json:"offset"`
	Range     interface{}  `json:"range"`
	MatchDate sql.NullTime `json:"match_date"`
	Sortby    interface{}  `json:"sortby"`
}

type ListMatchesWithDetailsRow struct {
	ID           int32          `json:"id"`
	HomeTeamID   int32          `json:"home_team_id"`
	AwayTeamID   int32          `json:"away_team_id"`
	StadiumID    int32          `json:"stadium_id"`
	MatchDate    time.Time      `json:"match_date"`
	Session      string         `json:"session"`
	Status       string         `json:"status"`
	HomeTeamName sql.NullString `json:"home_team_name"`
	AwayTeamName sql.NullString `json:"away_team_name"`
	StadiumName  sql.NullString `json:"stadium_name"`
	Available    int64          `json:"available"`
	MinPrice     string         `json:"min_price"`
}

func (q *Queries) ListMatchesWithDetails(ctx context.Context, arg ListMatchesWithDetailsParams) ([]ListMatchesWithDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, listMatchesWithDetails,
		arg.Limit,
		arg.Offset,
		arg.Range,
		arg.MatchDate,
		arg.Sortby,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMatchesWithDetailsRow{}
	for rows.Next() {
		var i ListMatchesWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.StadiumID,
			&i.MatchDate,
			&i.Session,
			&i.Status,
			&i.HomeTeamName,
			&i.AwayTeamName,
			&i.StadiumName,
			&i.Available,
			&i.MinPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMatch = `-- name: UpdateMatch :exec
UPDATE matches
SET home_team_id = coalesce($2, home_team_id),
    away_team_id = coalesce($3, away_team_id),
    stadium_id = coalesce($4, stadium_id),
    match_date = coalesce($5, match_date),
    session = coalesce($6, session),
    status = coalesce($7, status)
WHERE id=$1
`

type UpdateMatchParams struct {
	ID         int32          `json:"id"`
	HomeTeamID sql.NullInt32  `json:"home_team_id"`
	AwayTeamID sql.NullInt32  `json:"away_team_id"`
	StadiumID  sql.NullInt32  `json:"stadium_id"`
	MatchDate  sql.NullTime   `json:"match_date"`
	Session    sql.NullString `json:"session"`
	Status     sql.NullString `json:"status"`
}

func (q *Queries) UpdateMatch(ctx context.Context, arg UpdateMatchParams) error {
	_, err := q.db.ExecContext(ctx, updateMatch,
		arg.ID,
		arg.HomeTeamID,
		arg.AwayTeamID,
		arg.StadiumID,
		arg.MatchDate,
		arg.Session,
		arg.Status,
	)
	return err
}
