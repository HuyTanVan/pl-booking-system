// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: seat.sql

package db

import (
	"context"
	"database/sql"
)

const createSeat = `-- name: CreateSeat :one
INSERT INTO seats (
    stadium_id,
    block,
    row,
    seat_column,
    seat_available
)  
VALUES ($1, $2, $3, $4, $5)
RETURNING id, stadium_id, block, row, seat_column, seat_available
`

type CreateSeatParams struct {
	StadiumID     int32  `json:"stadium_id"`
	Block         string `json:"block"`
	Row           string `json:"row"`
	SeatColumn    string `json:"seat_column"`
	SeatAvailable int32  `json:"seat_available"`
}

func (q *Queries) CreateSeat(ctx context.Context, arg CreateSeatParams) (Seat, error) {
	row := q.db.QueryRowContext(ctx, createSeat,
		arg.StadiumID,
		arg.Block,
		arg.Row,
		arg.SeatColumn,
		arg.SeatAvailable,
	)
	var i Seat
	err := row.Scan(
		&i.ID,
		&i.StadiumID,
		&i.Block,
		&i.Row,
		&i.SeatColumn,
		&i.SeatAvailable,
	)
	return i, err
}

const getSeatByID = `-- name: GetSeatByID :one
SELECT id, stadium_id, block, row, seat_column, seat_available FROM seats
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSeatByID(ctx context.Context, id int32) (Seat, error) {
	row := q.db.QueryRowContext(ctx, getSeatByID, id)
	var i Seat
	err := row.Scan(
		&i.ID,
		&i.StadiumID,
		&i.Block,
		&i.Row,
		&i.SeatColumn,
		&i.SeatAvailable,
	)
	return i, err
}

const listSeats = `-- name: ListSeats :many
SELECT id, stadium_id, block, row, seat_column, seat_available FROM seats
WHERE seats.stadium_id = $1
ORDER BY id
LIMIT $2
OFFSET $3
`

type ListSeatsParams struct {
	StadiumID int32 `json:"stadium_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

func (q *Queries) ListSeats(ctx context.Context, arg ListSeatsParams) ([]Seat, error) {
	rows, err := q.db.QueryContext(ctx, listSeats, arg.StadiumID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Seat{}
	for rows.Next() {
		var i Seat
		if err := rows.Scan(
			&i.ID,
			&i.StadiumID,
			&i.Block,
			&i.Row,
			&i.SeatColumn,
			&i.SeatAvailable,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSeatsWithDetails = `-- name: ListSeatsWithDetails :many
SELECT s.id, s.stadium_id, s.block, s.row, s.seat_column, s.seat_available, 
       stadium.name AS stadium_name
FROM seats s
LEFT JOIN stadiums AS stadium ON s.stadium_id = $1
LIMIT $2
OFFSET $3
`

type ListSeatsWithDetailsParams struct {
	StadiumID int32 `json:"stadium_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type ListSeatsWithDetailsRow struct {
	ID            int32          `json:"id"`
	StadiumID     int32          `json:"stadium_id"`
	Block         string         `json:"block"`
	Row           string         `json:"row"`
	SeatColumn    string         `json:"seat_column"`
	SeatAvailable int32          `json:"seat_available"`
	StadiumName   sql.NullString `json:"stadium_name"`
}

func (q *Queries) ListSeatsWithDetails(ctx context.Context, arg ListSeatsWithDetailsParams) ([]ListSeatsWithDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, listSeatsWithDetails, arg.StadiumID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSeatsWithDetailsRow{}
	for rows.Next() {
		var i ListSeatsWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.StadiumID,
			&i.Block,
			&i.Row,
			&i.SeatColumn,
			&i.SeatAvailable,
			&i.StadiumName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSeatAvailable = `-- name: UpdateSeatAvailable :exec

UPDATE seats
SET seat_available = $1
WHERE id = $2
`

type UpdateSeatAvailableParams struct {
	SeatAvailable int32 `json:"seat_available"`
	ID            int32 `json:"id"`
}

// -- name: UpdateUser :exec
// UPDATE payment_methods
// SET first_name = coalesce(sqlc.narg('first_name'), first_name),
//
//	last_name = coalesce(sqlc.narg('last_name'), last_name),
//	password = coalesce(sqlc.narg('password'), password),
//	phone_number = coalesce(sqlc.narg('phone_number'), phone_number),
//	is_active = coalesce(sqlc.narg('is_active'), is_active)
//
// WHERE id=$1;
func (q *Queries) UpdateSeatAvailable(ctx context.Context, arg UpdateSeatAvailableParams) error {
	_, err := q.db.ExecContext(ctx, updateSeatAvailable, arg.SeatAvailable, arg.ID)
	return err
}
